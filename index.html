<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chat com Luna 💖</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <div id="main-layout">
      <section id="historico-container">
        <h2>Histórico de Conversas 💬</h2>
        <button id="btn-novo-chat" class="action-button">✨ Novo Chat</button>
        <ul id="lista-sessoes">
          <li>Nenhuma conversa encontrada.</li>
        </ul>
      </section>

      <div id="chat-container">
        <h1>Conversando com Luna 💖</h1>

        <div id="chat-log"></div>

        <div id="status"></div>

        <form id="prompt-form">
          <div id="input-area">
            <textarea
              id="prompt-input"
              rows="1"
              placeholder="Digite sua mensagem..."
            ></textarea>
            <button id="submit-button" type="submit">Enviar</button>
          </div>
        </form>
      </div>
    </div>

    <script>
      // --- ELEMENTOS DO DOM ---
      const form = document.getElementById("prompt-form");
      const promptInput = document.getElementById("prompt-input");
      const submitButton = document.getElementById("submit-button");
      const chatLog = document.getElementById("chat-log");
      const statusDiv = document.getElementById("status");
      const historicoContainer = document.getElementById("historico-container");
      const listaSessoes = document.getElementById("lista-sessoes");
      const btnNovoChat = document.getElementById("btn-novo-chat"); // Novo botão

      // --- CONFIGURAÇÕES ---
      const backendBaseUrl = "https://luna-botnamoradeiro.onrender.com";
      const CHAT_HISTORY_KEY = "luna_chat_history_v004";
      const SESSION_ID_KEY = "luna_session_id";

      // --- FUNÇÕES ---
      function getSessionId() {
        let sessionId = localStorage.getItem(SESSION_ID_KEY);
        if (!sessionId) {
          sessionId = `sess-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
          localStorage.setItem(SESSION_ID_KEY, sessionId);
        }
        return sessionId;
      }
      let currentSessionId = getSessionId();

      function formatTime(dateString) {
        const date = dateString ? new Date(dateString) : new Date();
        return date.toLocaleTimeString("pt-BR", {
          hour: "2-digit",
          minute: "2-digit",
          hour12: false,
        });
      }

      function addMessageToLog(sender, message, timestamp) {
        const messageContainer = document.createElement("div");
        messageContainer.classList.add("message-container");

        const messageDiv = document.createElement("div");
        messageDiv.classList.add("message");

        if (sender === "user") {
          messageContainer.classList.add("user-message-container");
          messageDiv.classList.add("user-message");
        } else if (sender === "ai") {
          messageContainer.classList.add("ai-message-container");
          messageDiv.classList.add("ai-message");
        } else if (sender === "error") {
          messageContainer.classList.add("error-message-container");
          messageDiv.classList.add("error-message");
        }

        messageDiv.textContent = message;
        messageContainer.appendChild(messageDiv);

        if (sender !== "error") {
          const timeDiv = document.createElement("div");
          timeDiv.classList.add("message-time");
          timeDiv.textContent = formatTime(timestamp);
          messageContainer.appendChild(timeDiv);
        }

        chatLog.appendChild(messageContainer);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      async function fetchAndDisplayInitialDateTime() {
        try {
          const response = await fetch(`${backendBaseUrl}/api/datetime`);
          if (!response.ok) throw new Error(`Erro ${response.status}`);
          const data = await response.json();
          const dateTimeDiv = document.createElement("div");
          dateTimeDiv.classList.add("initial-date-time");
          dateTimeDiv.textContent = `Hoje é ${data.datetime} 💕`;
          chatLog.appendChild(dateTimeDiv);
        } catch (error) {
          console.error("Falha ao buscar data/hora:", error);
        }
      }

      async function loadChatHistoryFromBackend(sessionIdToLoad = currentSessionId) {
        console.log(`[FRONTEND] Carregando histórico da sessão ${sessionIdToLoad} do backend...`);
        chatLog.innerHTML = "";
        await fetchAndDisplayInitialDateTime();

        try {
          const response = await fetch(`${backendBaseUrl}/api/chat/historicos?sessao=${sessionIdToLoad}`);
          if (!response.ok) {
            addMessageToLog("ai", "Oi, meu amor! 🥰 Que bom te ver por aqui! Como você tá hoje?", new Date().toISOString());
            return;
          }
          const sessionDetails = await response.json();
          const messages = sessionDetails.messages;

          if (messages && messages.length > 0) {
            messages.forEach((msg) => addMessageToLog(msg.sender, msg.text, msg.timestamp));
          } else {
            addMessageToLog("ai", "Oi, meu amor! 🥰 Que bom te ver por aqui! Como você tá hoje?", new Date().toISOString());
          }
        } catch (error) {
          console.error("Erro ao carregar histórico da sessão do backend:", error);
          addMessageToLog("error", "Ops, não consegui carregar nosso histórico agora. Mas estou aqui para você! 💖", new Date().toISOString());
        }
      }

      function updateLocalStorageHistory(sender, text, timestamp) {
        try {
          const savedHistory = localStorage.getItem(CHAT_HISTORY_KEY);
          const history = savedHistory ? JSON.parse(savedHistory) : [];
          history.push({ sender, text, timestamp: timestamp || new Date().toISOString() });
          if (history.length > 50) history.splice(0, history.length - 50);
          localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));
        } catch (e) {
          console.error("Falha ao atualizar histórico no LocalStorage:", e);
        }
      }

      async function carregarHistoricoSessoes() {
        try {
          const response = await fetch(`${backendBaseUrl}/api/chat/historicos`);
          if (!response.ok) throw new Error(`Erro ${response.status}`);
          const sessoes = await response.json();
          listaSessoes.innerHTML = "";

          if (sessoes.length === 0) {
            listaSessoes.innerHTML = "<li>Nenhuma conversa encontrada.</li>";
            return;
          }

          sessoes.forEach((sessao) => {
            const li = document.createElement("li");
            li.dataset.sessionId = sessao.sessionId;
            if (sessao.sessionId === currentSessionId) {
                li.classList.add('current-session');
            }

            const infoDiv = document.createElement("div");
            infoDiv.classList.add("conversa-info");
            const tituloDiv = document.createElement("div");
            tituloDiv.classList.add("conversa-titulo");
            const data = new Date(sessao.startTime).toLocaleString("pt-BR");
            tituloDiv.textContent = `Conversa de ${data} (${sessao.messageCount} msgs)`;
            const previewDiv = document.createElement("div");
            previewDiv.classList.add("conversa-preview");
            const previewText = sessao.primeiraMensagem || "(Sem prévia disponível)";
            previewDiv.textContent = previewText.length > 50 ? `${previewText.substring(0, 50)}...` : previewText;
            infoDiv.appendChild(tituloDiv);
            infoDiv.appendChild(previewDiv);

            const btnExcluir = document.createElement("button");
            btnExcluir.classList.add("btn-excluir");
            btnExcluir.innerHTML = "🗑️";
            btnExcluir.title = "Excluir conversa";

            btnExcluir.addEventListener("click", (e) => {
              e.stopPropagation();
              excluirConversa(sessao.sessionId);
            });

            li.addEventListener("click", () => {
                if (sessao.sessionId !== currentSessionId) {
                    localStorage.setItem(SESSION_ID_KEY, sessao.sessionId);
                    currentSessionId = sessao.sessionId;
                    loadChatHistoryFromBackend(currentSessionId);
                    carregarHistoricoSessoes();
                }
            });

            li.appendChild(infoDiv);
            li.appendChild(btnExcluir);
            listaSessoes.appendChild(li);
          });
        } catch (error) {
          console.error("Erro ao carregar histórico:", error);
          listaSessoes.innerHTML = "<li>Erro ao carregar o histórico. 😢</li>";
        }
      }

      async function excluirConversa(sessionIdToDelete) {
        if (!confirm("Tem certeza que deseja excluir esta conversa? A ação não pode ser desfeita.")) return;
        try {
          const response = await fetch(`${backendBaseUrl}/api/chat/historicos/${sessionIdToDelete}`, { method: "DELETE" });
          const data = await response.json();
          if (!response.ok) throw new Error(data.error || "Falha ao excluir.");
          alert(data.message || "Conversa excluída com sucesso!");
          carregarHistoricoSessoes();

          if (sessionIdToDelete === currentSessionId) {
            localStorage.removeItem(SESSION_ID_KEY);
            currentSessionId = getSessionId();
            loadChatHistoryFromBackend(currentSessionId);
          }
        } catch (error) {
          console.error("Erro ao excluir conversa:", error);
          alert(`Não foi possível excluir a conversa. Erro: ${error.message}`);
        }
      }

      async function sendChatMessage() {
        const userPrompt = promptInput.value.trim();
        if (!userPrompt) return;

        const userMessageTimestamp = new Date().toISOString();
        addMessageToLog("user", userPrompt, userMessageTimestamp);
        // Não chame updateLocalStorageHistory aqui, pois o backend irá persistir.
        // Se você ainda quiser um "cache" local temporário para a sessão atual,
        // precisaria replicar a lógica de histórico aqui ou recarregar do backend.
        // Para simplificar, vou assumir que o frontend confia no backend para o histórico completo.

        promptInput.value = "";
        promptInput.style.height = "auto";
        submitButton.disabled = true;
        statusDiv.textContent = "Luna está digitando... 💭";

        try {
          // --- NOVO: Carregar o histórico atual do chatLog para enviar ao backend ---
          // O backend irá revalidar/reconstruir o histórico completo, mas enviar o que está na tela ajuda
          // a manter a coerência em caso de pequenos atrasos ou diferenças.
          // No entanto, para o método que sugeri no server.js (onde ele busca do DB),
          // o history do frontend não é estritamente necessário para o Gemini, apenas o `sessionId`.
          // Vou remover a passagem do `history` daqui para simplificar e confiar no backend.
          // Apenas o `sessionId` e o `prompt` serão enviados.

          const response = await fetch(`${backendBaseUrl}/api/generate`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            // --- MODIFICAÇÃO CHAVE AQUI: Adicionar sessionId ao body ---
            body: JSON.stringify({ prompt: userPrompt, sessionId: currentSessionId }),
          });
          const data = await response.json();
          if (!response.ok) throw new Error(data.error || `Erro ${response.status}`);

          const aiMessageTimestamp = new Date().toISOString();
          addMessageToLog("ai", data.generatedText, aiMessageTimestamp);
          // Não chame updateLocalStorageHistory aqui, pois o backend já persistiu.

          // Recarregar o histórico de sessões para que a sessão atual apareça atualizada (msgs count, preview)
          carregarHistoricoSessoes();
        } catch (error) {
          console.error("Erro no chat:", error);
          addMessageToLog("error", `Puxa, amor, tive um probleminha aqui: ${error.message} 😢`, new Date().toISOString());
        } finally {
          submitButton.disabled = false;
          statusDiv.textContent = "";
          promptInput.focus();
        }
      }

      // --- EVENT LISTENERS ---
      promptInput.addEventListener("input", () => {
        promptInput.style.height = "auto";
        promptInput.style.height = promptInput.scrollHeight + "px";
      });

      // Novo: Enviar mensagem com Ctrl + Enter
      promptInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter" && (event.ctrlKey || event.metaKey)) { // metaKey para macOS
          event.preventDefault(); // Impede a quebra de linha no textarea
          sendChatMessage();
        }
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        sendChatMessage();
      });

      // Novo: Botão "Novo Chat"
      btnNovoChat.addEventListener('click', () => {
          if (confirm("Tem certeza que deseja iniciar um novo chat? A conversa atual será salva no histórico.")) {
              // Limpa o sessionId atual e gera um novo
              localStorage.removeItem(SESSION_ID_KEY);
              // Nao precisa limpar CHAT_HISTORY_KEY pois o histórico agora vem do backend
              currentSessionId = getSessionId(); // Isso irá gerar um novo ID
              loadChatHistoryFromBackend(currentSessionId); // Inicia um novo chat vazio
              carregarHistoricoSessoes(); // Atualiza a lista de histórico (a sessão anterior agora está salva)
              promptInput.focus();
          }
      });


      // --- ROTINAS DE INICIALIZAÇÃO E CICLO DE VIDA ---
      window.addEventListener("load", () => {
        currentSessionId = getSessionId();
        loadChatHistoryFromBackend(currentSessionId);
        carregarHistoricoSessoes();

        fetch(`${backendBaseUrl}/api/log-connection`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ acao: "acesso_inicial_chatbot", sessionId: currentSessionId }), // Opcional: registrar sessionId
        }).catch((err) => console.error("Erro ao registrar log de conexão:", err));
        fetch(`${backendBaseUrl}/api/ranking/registrar-acesso-bot`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ botId: "luna-namoradeira", nomeBot: "Luna" }),
        }).catch((err) => console.error("Erro ao registrar acesso para ranking:", err));
      });
    </script>
  </body>
</html>